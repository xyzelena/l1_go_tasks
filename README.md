# L1 Go Tasks

## Старт

```bash
# Запуск через Go
go run main.go
```

## Доступные команды

### Основные команды
- `make run` - запустить все примеры
- `make build` - собрать приложение в bin/
- `make clean` - очистить собранные файлы
- `make run-race` - запустить с race detector

### Инструменты разработки
- `make fmt` - отформатировать код
- `make vet` - проверить код с go vet  
- `make lint` - запустить golangci-lint
- `make lint-fix` - автоисправления линтера
- `make test` - запустить тесты
- `make test-cover` - тесты с покрытием
- `make check` - полная проверка (fmt + vet + lint + test)

### Управление зависимостями
- `make deps` - скачать зависимости
- `make mod-tidy` - очистить go.mod
- `make install-tools` - установить инструменты разработки

## Задача 1 - Human (embedded structs)

Дана структура Human (с произвольным набором полей и методов).

Реализовано встраивание методов в структуре Action от родительской структуры Human (аналог наследования)с помощью композиции (embedded struct), чтобы Action имел все методы Human.

## Задача 2 - Squaring (goroutines & channels)

Программа, которая конкурентно рассчитает значения квадратов чисел, взятых из массива [2,4,6,8,10], и выводит результаты в stdout.
Применяются несколько горутин, каждая из которых возводит число в квадрат.

Задача выполнена в двух вариантах: 
1. Через каналы (`squaring/squaring1.go`)
2. Через WaitGroup (`squaring/squaring2.go`)

## Задача 3,4 - Workers

В задаче №3 реализована система с N воркерами, читающими данные из канала.

Реализация включает:
   - Создание N горутин-воркеров с уникальными ID
   - Использование буферизованного канала для передачи данных
   - Синхронизацию через WaitGroup
   - Graceful shutdown через context

В задаче № 4 реализовано корректное завершение по нажатию Ctrl+C (SIGINT).

В этом примере для завершения работы используется контекст (context.Context), потому что это стандартный способ в Go передавать сигнал об остановке и управлять временем жизни горутин.
Через signal.NotifyContext контекст связывается с сигналами ОС (SIGINT, SIGTERM), поэтому программу можно завершить по нажатию Ctrl+C.
Канал закрывается только в генераторе, поэтому исключает ошибки и позволяет воркерам завершить работу.
Такой вариант делает завершение программы предсказуемым, без утечек горутин, и соответствует практикам Go.

## Задача 5 - TimeoutChannel

Разработана программа, которая последовательно отправлять значения в канал, а с другой стороны канала читаются эти значения. По истечении N секунд программа завершается.

## Задача 6 - GoroutineStops

Реализованы различные способы остановки горутин:

1. Через context.Context и отмену контекста
2. Через канал для передачи сигнала остановки
3. По условию в цикле
4. Через runtime.Goexit()
5. Через context с таймаутом
6. Через atomic флаг
7. Через закрытие канала
8. Через panic/recover

Каждый способ демонстрирует разные подходы к управлению жизненным циклом горутин:

- Context - идиоматичный способ для отмены операций
- Каналы - для явной передачи сигналов остановки
- Условия - для простых случаев
- Runtime.Goexit - для немедленного завершения
- Timeout - для ограничения времени выполнения
- Atomic - для атомарного доступа к флагам
- Close - для сигнализации через закрытие канала
- Panic/Recover - для аварийного завершения с восстановлением

Все примеры включают:
- Атомарный счетчик для демонстрации работы
- Синхронизацию через WaitGroup
- Вывод начального и конечного значений

## Задача 7 - Concurrent entry in the map

Реализована безопасная для конкуренции запись данных в структуру map 2 способами синхронизации: 

1. Через sync.Mutex:
- Использование RWMutex для синхронизации доступа к map
- Показаны добавление/удаление товаров в списке покупок

2. Через sync.Map:
- Использование потокобезопасной структуры sync.Map
- Показаны добавление/удаление уроков и преподавателей

## Задача 8 - Setting a bit in a number

Разработана программа для работы с битами в числах типа int64. Программа позволяет устанавливать i-й бит числа в 1 или 0 с использованием битовых операций.

### Реализованные функции:

- **SetBit(n int64, pos int, value int) (int64, int)** - устанавливает бит в позиции `pos` в значение `value` (0 или 1), возвращает новое число и старое значение бита

### Используемые битовые операции:

- **OR (|)** - для установки бита в 1: `n |= (1 << pos)`
- **AND NOT (&^)** - для установки бита в 0: `n &^= (1 << pos)`
- **Сдвиг влево (<<)** - для создания маски: `1 << pos`
- **Сдвиг вправо (>>)** - для получения значения бита: `(n >> pos) & 1`

### Пример работы:

Для числа 5 (0101₂):
- Установка 1-го бита в 0: 5 → 4 (0101₂ → 0100₂)
- Установка 1-го бита в 1: 5 → 7 (0101₂ → 0111₂)

### Особенности реализации:

- Функция возвращает как новое значение числа, так и предыдущее значение измененного бита
- Используется int64 для работы с большими числами
- Позиция бита считается с 0 (младший бит справа)
- Безопасная работа с битовыми масками

## Задача 9 - Number pipeline

Разработан конвейер чисел из двух этапов с горутинами: генерация чисел и их обработка.  
Даны два канала: в первый пишутся числа x из массива, во второй – результат операции x*2. После этого данные из второго канала выводятся в stdout. 

## Задача 10 - Temperature grouping

Дана последовательность температурных колебаний: -25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. 
В данном примере эти значения были объедены в группы с шагом 10 градусов.
Пример: -20:{-25.4, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20:{24.5}, 30:{32.5}.

## Задача 11 - Intersection of Sets

В данном примере было реализовано пересечение двух неупорядоченных множеств (двух слайсов) — т.е. вынесены элементы, присутствующие и в первом, и во втором в отдельный слайс. 

Пример:
A = {1,2,3}
B = {2,3,4}
Пересечение = {2,3}

## Задача 12 - Set of unique strings

Для последовательности строк: ("cat", "cat", "dog", "cat", "tree")
было создано собственное множество map[string]struct{} где ключ — уникальное слово из этой последовательности, а значение — пустая структура (занимает 0 байт).
Для примера, множество {"cat", "dog", "tree"}.

## Задача 13 - Exchange of values ​​without a third variable 

В данном примере рассмотрены 3 способа поменять местами два числа без использования временной переменной: сложение/вычитание, XOR-обмен и через множественное (или параллельное) присваивание.

## Задача 14 - Determining the type of a variable at runtime 

В данном примере разработана программа, которая в runtime определяет тип переменной, переданной в неё (на вход подаётся interface{}). 

Для решения задачи был использован оператор типа switch v.(type) для простых базовых типов (int, string, bool, chan), а если тип не распознан, используется reflect.TypeOf() 

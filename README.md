# L1 Go Tasks

## Структура проекта

```
l1_go_tasks/
├── go.mod              # Описание модуля Go
├── main.go             # Главный файл с примерами запуска
├── Makefile            # Команды для сборки и управления проектом
├── human/              # Пакет с примером встроенных структур
│   ├── human.go        # Базовая структура Human
│   └── action.go       # Структура Action с встраиванием Human
├── squaring/           # Пакет с примерами параллельных вычислений
│   ├── squaring1.go    # Реализация через каналы
│   └── squaring2.go    # Реализация через sync.WaitGroup
└── workers/            # Пакет с реализацией worker pool
    └── workers.go      # Worker pool с graceful shutdown
```

## Старт

```bash
# Запуск через Go
go run main.go
```

## Доступные команды

### Основные команды
- `make run` - запустить все примеры
- `make build` - собрать приложение в bin/
- `make clean` - очистить собранные файлы
- `make run-race` - запустить с race detector

### Инструменты разработки
- `make fmt` - отформатировать код
- `make vet` - проверить код с go vet  
- `make lint` - запустить golangci-lint
- `make lint-fix` - автоисправления линтера
- `make test` - запустить тесты
- `make test-cover` - тесты с покрытием
- `make check` - полная проверка (fmt + vet + lint + test)

### Управление зависимостями
- `make deps` - скачать зависимости
- `make mod-tidy` - очистить go.mod
- `make install-tools` - установить инструменты разработки

## Задача 1 - Human (embedded structs)

Работа со встроенными структурами в Go как альтернатива наследованию.

### Реализация:

**Базовая структура Human** (`human/human.go`):
- Приватное поле `name string`
- Методы: `SetName(string)`, `GetName() string`, `SayHello()`

**Расширенная структура Action** (`human/action.go`):
- Встраивание структуры `Human` (composition over inheritance)
- Дополнительное поле `age int`
- Методы: `SetAge(int)`, `GetAge() int`, `Introduce()`
- Автоматический доступ к методам Human через встраивание

## Задача 2 - Squaring (goroutines & channels)

Сравнение двух подходов к параллельным вычислениям в Go.

### Вариант 1: Каналы (`squaring/squaring1.go`)

**Особенности реализации:**
- Буферизованный канал `chan result` размером с массив
- Структура `result` для сохранения порядка элементов
- Горутины отправляют результаты в канал
- Главная горутина собирает результаты и восстанавливает порядок

### Вариант 2: WaitGroup (`squaring/squaring2.go`)

**Особенности реализации:**
- `sync.WaitGroup` для синхронизации горутин
- Прямая запись в слайс по индексу (race condition безопасно)
- `defer wg.Done()` в каждой горутине
- `wg.Wait()` для ожидания завершения всех горутин

### Сравнение подходов:
- **Каналы**: безопасность типов, явная передача данных, легче отладка
- **WaitGroup**: меньше overhead, прямой доступ к памяти, проще код

## Задача 3,4 - Workers

В данном примере реализована система с N воркерами, читающими данные из канала:

1. Реализация включает:
   - Создание N горутин-воркеров с уникальными ID
   - Использование буферизованного канала для передачи данных
   - Синхронизацию через WaitGroup
   - Graceful shutdown через context

2. Основные компоненты:
   - Worker() - функция воркера с ID, читающая данные из канала
   - DoWorkers() - функция запуска системы воркеров с параметром количества
   - Главная горутина для постоянной записи данных в канал
   - Context для корректной отмены горутин

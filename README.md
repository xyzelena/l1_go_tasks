# L1 Go Tasks

## Старт

```bash
# Запуск через Go
go run main.go
```

## Доступные команды

### Основные команды
- `make run` - запустить все примеры
- `make build` - собрать приложение в bin/
- `make clean` - очистить собранные файлы
- `make run-race` - запустить с race detector

### Инструменты разработки
- `make fmt` - отформатировать код
- `make vet` - проверить код с go vet  
- `make lint` - запустить golangci-lint
- `make lint-fix` - автоисправления линтера
- `make test` - запустить тесты
- `make test-cover` - тесты с покрытием
- `make check` - полная проверка (fmt + vet + lint + test)

### Управление зависимостями
- `make deps` - скачать зависимости
- `make mod-tidy` - очистить go.mod
- `make install-tools` - установить инструменты разработки

## Задача 1 - Human (embedded structs)

Дана структура Human (с произвольным набором полей и методов).

Реализовано встраивание методов в структуре Action от родительской структуры Human (аналог наследования)с помощью композиции (embedded struct), чтобы Action имел все методы Human.

## Задача 2 - Squaring (goroutines & channels)

Программа, которая конкурентно рассчитает значения квадратов чисел, взятых из массива [2,4,6,8,10], и выводит результаты в stdout.
Применяются несколько горутин, каждая из которых возводит число в квадрат.

Задача выполнена в двух вариантах: 
1. Через каналы (`squaring/squaring1.go`)
2. Через WaitGroup (`squaring/squaring2.go`)

## Задача 3,4 - Workers

В задаче №3 реализована система с N воркерами, читающими данные из канала.

Реализация включает:
   - Создание N горутин-воркеров с уникальными ID
   - Использование буферизованного канала для передачи данных
   - Синхронизацию через WaitGroup
   - Graceful shutdown через context

В задаче № 4 реализовано корректное завершение по нажатию Ctrl+C (SIGINT).

В этом примере для завершения работы используется контекст (context.Context), потому что это стандартный способ в Go передавать сигнал об остановке и управлять временем жизни горутин.
Через signal.NotifyContext контекст связывается с сигналами ОС (SIGINT, SIGTERM), поэтому программу можно завершить по нажатию Ctrl+C.
Канал закрывается только в генераторе, поэтому исключает ошибки и позволяет воркерам завершить работу.
Такой вариант делает завершение программы предсказуемым, без утечек горутин, и соответствует практикам Go.

## Задача 5 - TimeoutChannel

Разработана программа, которая последовательно отправлять значения в канал, а с другой стороны канала читаются эти значения. По истечении N секунд программа завершается.

## Задача 6 - GoroutineStops

Реализованы различные способы остановки горутин:

1. Через context.Context и отмену контекста
2. Через канал для передачи сигнала остановки
3. По условию в цикле
4. Через runtime.Goexit()
5. Через context с таймаутом
6. Через atomic флаг
7. Через закрытие канала
8. Через panic/recover

Каждый способ демонстрирует разные подходы к управлению жизненным циклом горутин:

- Context - идиоматичный способ для отмены операций
- Каналы - для явной передачи сигналов остановки
- Условия - для простых случаев
- Runtime.Goexit - для немедленного завершения
- Timeout - для ограничения времени выполнения
- Atomic - для атомарного доступа к флагам
- Close - для сигнализации через закрытие канала
- Panic/Recover - для аварийного завершения с восстановлением

Все примеры включают:
- Атомарный счетчик для демонстрации работы
- Синхронизацию через WaitGroup
- Вывод начального и конечного значений

## Задача 7 - Concurrent entry in the map

Реализована безопасная для конкуренции запись данных в структуру map 2 способами синхронизации: 

1. Через sync.Mutex:
- Использование RWMutex для синхронизации доступа к map
- Показаны добавление/удаление товаров в списке покупок

2. Через sync.Map:
- Использование потокобезопасной структуры sync.Map
- Показаны добавление/удаление уроков и преподавателей

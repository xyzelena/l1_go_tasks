# L1 Go Tasks

## Старт

```bash
# Запуск через Go
go run main.go
```

## Доступные команды

### Основные команды
- `make run` - запустить все примеры
- `make build` - собрать приложение в bin/
- `make clean` - очистить собранные файлы
- `make run-race` - запустить с race detector

### Инструменты разработки
- `make fmt` - отформатировать код
- `make vet` - проверить код с go vet  
- `make lint` - запустить golangci-lint
- `make lint-fix` - автоисправления линтера
- `make test` - запустить тесты
- `make test-cover` - тесты с покрытием
- `make check` - полная проверка (fmt + vet + lint + test)

### Управление зависимостями
- `make deps` - скачать зависимости
- `make mod-tidy` - очистить go.mod
- `make install-tools` - установить инструменты разработки

## Задача 1 - Human (embedded structs)

Дана структура Human (с произвольным набором полей и методов).

Реализовано встраивание методов в структуре Action от родительской структуры Human (аналог наследования)с помощью композиции (embedded struct), чтобы Action имел все методы Human.

## Задача 2 - Squaring (goroutines & channels)

Программа, которая конкурентно рассчитает значения квадратов чисел, взятых из массива [2,4,6,8,10], и выводит результаты в stdout.
Применяются несколько горутин, каждая из которых возводит число в квадрат.

Задача выполнена в двух вариантах: 
1. Через каналы (`squaring/squaring1.go`)
2. Через WaitGroup (`squaring/squaring2.go`)

## Задача 3,4 - Workers

В задаче №3 реализована система с N воркерами, читающими данные из канала.

Реализация включает:
   - Создание N горутин-воркеров с уникальными ID
   - Использование буферизованного канала для передачи данных
   - Синхронизацию через WaitGroup
   - Graceful shutdown через context

В задаче № 4 реализовано корректное завершение по нажатию Ctrl+C (SIGINT).

В этом примере для завершения работы используется контекст (context.Context), потому что это стандартный способ в Go передавать сигнал об остановке и управлять временем жизни горутин.
Через signal.NotifyContext контекст связывается с сигналами ОС (SIGINT, SIGTERM), поэтому программу можно завершить по нажатию Ctrl+C.
Канал закрывается только в генераторе, поэтому исключает ошибки и позволяет воркерам завершить работу.
Такой вариант делает завершение программы предсказуемым, без утечек горутин, и соответствует практикам Go.

## Задача 5 - TimeoutChannel

Разработана программа, которая последовательно отправлять значения в канал, а с другой стороны канала читаются эти значения. По истечении N секунд программа завершается.

## Задача 6 - GoroutineStops

Реализованы различные способы остановки горутин:

1. Через context.Context и отмену контекста
2. Через канал для передачи сигнала остановки
3. По условию в цикле
4. Через runtime.Goexit()
5. Через context с таймаутом
6. Через atomic флаг
7. Через закрытие канала
8. Через panic/recover

Каждый способ демонстрирует разные подходы к управлению жизненным циклом горутин:

- Context - идиоматичный способ для отмены операций
- Каналы - для явной передачи сигналов остановки
- Условия - для простых случаев
- Runtime.Goexit - для немедленного завершения
- Timeout - для ограничения времени выполнения
- Atomic - для атомарного доступа к флагам
- Close - для сигнализации через закрытие канала
- Panic/Recover - для аварийного завершения с восстановлением

Все примеры включают:
- Атомарный счетчик для демонстрации работы
- Синхронизацию через WaitGroup
- Вывод начального и конечного значений

## Задача 7 - Concurrent entry in the map

Реализована безопасная для конкуренции запись данных в структуру map 2 способами синхронизации: 

1. Через sync.Mutex:
- Использование RWMutex для синхронизации доступа к map
- Показаны добавление/удаление товаров в списке покупок

2. Через sync.Map:
- Использование потокобезопасной структуры sync.Map
- Показаны добавление/удаление уроков и преподавателей

## Задача 8 - Setting a bit in a number

Разработана программа для работы с битами в числах типа int64. Программа позволяет устанавливать i-й бит числа в 1 или 0 с использованием битовых операций.

### Реализованные функции:

- **SetBit(n int64, pos int, value int) (int64, int)** - устанавливает бит в позиции `pos` в значение `value` (0 или 1), возвращает новое число и старое значение бита

### Используемые битовые операции:

- **OR (|)** - для установки бита в 1: `n |= (1 << pos)`
- **AND NOT (&^)** - для установки бита в 0: `n &^= (1 << pos)`
- **Сдвиг влево (<<)** - для создания маски: `1 << pos`
- **Сдвиг вправо (>>)** - для получения значения бита: `(n >> pos) & 1`

### Пример работы:

Для числа 5 (0101₂):
- Установка 1-го бита в 0: 5 → 4 (0101₂ → 0100₂)
- Установка 1-го бита в 1: 5 → 7 (0101₂ → 0111₂)

### Особенности реализации:

- Функция возвращает как новое значение числа, так и предыдущее значение измененного бита
- Используется int64 для работы с большими числами
- Позиция бита считается с 0 (младший бит справа)
- Безопасная работа с битовыми масками

## Задача 9 - Number pipeline

Разработан конвейер чисел из двух этапов с горутинами: генерация чисел и их обработка.  
Даны два канала: в первый пишутся числа x из массива, во второй – результат операции x*2. После этого данные из второго канала выводятся в stdout. 

## Задача 10 - Temperature grouping

Дана последовательность температурных колебаний: -25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. 
В данном примере эти значения были объедены в группы с шагом 10 градусов.
Пример: -20:{-25.4, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20:{24.5}, 30:{32.5}.

## Задача 11 - Intersection of Sets

В данном примере было реализовано пересечение двух неупорядоченных множеств (двух слайсов) — т.е. вынесены элементы, присутствующие и в первом, и во втором в отдельный слайс. 

Пример:
A = {1,2,3}
B = {2,3,4}
Пересечение = {2,3}

## Задача 12 - Set of unique strings

Для последовательности строк: ("cat", "cat", "dog", "cat", "tree")
было создано собственное множество map[string]struct{} где ключ — уникальное слово из этой последовательности, а значение — пустая структура (занимает 0 байт).
Для примера, множество {"cat", "dog", "tree"}.

## Задача 13 - Exchange of values ​​without a third variable 

В данном примере рассмотрены 3 способа поменять местами два числа без использования временной переменной: сложение/вычитание, XOR-обмен и через множественное (или параллельное) присваивание.

## Задача 14 - Determining the type of a variable at runtime 

В данном примере разработана программа, которая в runtime определяет тип переменной, переданной в неё (на вход подаётся interface{}). 

Для решения задачи был использован оператор типа switch v.(type) для простых базовых типов (int, string, bool, chan), а если тип не распознан, используется reflect.TypeOf() 

## Задача 15 - Quick Sort

В данном примере был реализован алгоритм быстрой сортировки среза целых чисел с помощью рекурсии. 
Опорным элементом pivot была выбрана середина массива. 


## Задача 16 - Binary Search with loop and recursion

В данном примере реализован алгоритм бинарного поиска 2 способами: рекурсивно и итеративно, используя цикл for.
Функции принимают отсортированный слайс и искомый элемент, возвращают индекс элемента или -1, если элемент не найден.

## Задача 17 - Increment counter structure with mutex and atomic variants

В данном примере реализована структура-счётчик, которая инкрементируется в конкурентной среде (т.е. из нескольких горутин). По завершению программы структура выводит итоговое значение счётчика.

Пример реализован в двух вариантах с разными механизмами синхронизации: sync.Mutex и sync/Atomic для безопасного инкремента.

## Задача 18 - Reverse String

В данном примере реализована функция, которая переворачивает подаваемую на вход строку. Был применен срез рун ([]rune), так как символы могут быть в Unicode (русские буквы, emoji и пр.).

Например: при вводе строки «главрыба» вывод должен быть «абырвалг».

## Задача 19 - Word Reversal

В данном примере разработана программа, которая переворачивает порядок слов в строке.
При этом считается, что слова разделяются одиночным пробелом. Операции выполнены «на месте» а не через дополнительные срезы. 

Например: входная строка: «snow dog sun», выход: «sun dog snow».

## Задача 20 - Adapter pattern

В данном примере реализован паттерн проектирования «Адаптер».

Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Пример показан на простом примере в Go: есть существующий интерфейс (или структура) и другой, несовместимый по интерфейсу потребитель — создан адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

### Применимость паттерна Adapter:

* Если есть уже существующий компонент или библиотека, которую нельзя менять;
* Если клиент ожидает другой интерфейс;
* Если нужно обеспечить совместимость двух несвязанных типов.
* Если нужен переход от старого API к новому, когда оба должны работать какое-то время;
* Для интеграции стороннего кода в приложение;
* Для унификации разных источников данных под единый интерфейс.

### Плюсы паттерна: 

✔ Позволяет использовать несовместимый код, не изменяя его
✔ Делает систему гибче: можно легко менять реализацию
✔ Упрощает миграцию со старого API на новый
✔ Уменьшает дублирование кода

### Минусы паттерна:

- Усложняет архитектуру дополнительным уровнем абстракции
- Может возникнуть путаница при большом количестве адаптеров
- Иногда скрывает “кривой” дизайн — маскирует несовместимость, вместо того чтобы исправить её

### Примеры использования Adapter

+ Базы данных: адаптеры к разным драйверам (MySQL, Postgres) под общий интерфейс.
+ Логирование: обёртки вокруг Zap, Logrus, стандартного логгера.
+ Работа с облаками: приведение SDK AWS/Azure/GCP к единым внутренним интерфейсам.
+ Рендеринг, графика: разные движки с разными API приводятся к единому интерфейсу.
+ Файловые системы: адаптация локальных файлов и S3-хранилища под общий интерфейс.

## Задача 21 - Task 21 Large numbers and operations

В данном примере разработана программа, которая перемножает, делит, складывает, вычитает две числовых переменных a, b, значения которых > 2^20 (больше 1 миллион).
Для очень больших чисел применили math/big.

## Задача 22 - Task 22 Deleting slice element

В данном примере реализована функция для корректного удаления i-го элемента из слайса без утечки памяти.

Для этого применили встроенную функцию для копирования (copy(slice[i:], slice[i+1:])) и уменьшили длину слайса на 1.

## Задача 23 - Task 23 Distance between points

В данном примере разработана программа нахождения расстояния между двумя точками на плоскости. Точки представлены в виде структуры Point с инкапсулированными (приватными) полями x, y (типа float64) и конструктором. Расстояние рассчитывается по формуле между координатами двух точек.
Была использована функция-конструктор NewPoint(x, y), Point и метод Distance(other Point) float64.

## Задача 23 - Task 24 Function Sleep 

В данном примере реализована функция sleep(duration) аналогично встроенной функции time.Sleep, которая приостанавливает выполнение текущей горутины.
В отличие от настоящей time.Sleep, функция блокирует выполнение через канал и ожидание сигнала завершения. 




